<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IRIS A*: Polyhedron Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IRIS A*
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_polyhedron.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_polyhedron-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Polyhedron Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_polyhedron_8h_source.html">Polyhedron.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Polyhedron:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_polyhedron.png" usemap="#Polyhedron_map" alt=""/>
  <map id="Polyhedron_map" name="Polyhedron_map">
<area href="class_conic_set.html" alt="ConicSet" shape="rect" coords="0,0,205,24"/>
<area href="class_polyhedron_v.html" alt="PolyhedronV" shape="rect" coords="0,112,205,136"/>
<area href="class_polyhedron_obstacle_circular_robot.html" alt="PolyhedronObstacleCircularRobot" shape="rect" coords="0,168,205,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a37e84952f6ff4d4190076ce2fe269ee8" id="r_a37e84952f6ff4d4190076ce2fe269ee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37e84952f6ff4d4190076ce2fe269ee8">Polyhedron</a> (const int &amp;n)</td></tr>
<tr class="separator:a37e84952f6ff4d4190076ce2fe269ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac620c35abc2f14019b2bfc86aa839d8b" id="r_ac620c35abc2f14019b2bfc86aa839d8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac620c35abc2f14019b2bfc86aa839d8b">Polyhedron</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>)</td></tr>
<tr class="separator:ac620c35abc2f14019b2bfc86aa839d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a75082a4ec97a9190e7a6b74a6a0abb" id="r_a6a75082a4ec97a9190e7a6b74a6a0abb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a75082a4ec97a9190e7a6b74a6a0abb">Polyhedron</a> (const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;polyhedron)</td></tr>
<tr class="separator:a6a75082a4ec97a9190e7a6b74a6a0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8dd9f8f21a021f543461435076de8a" id="r_a8f8dd9f8f21a021f543461435076de8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f8dd9f8f21a021f543461435076de8a">~Polyhedron</a> ()</td></tr>
<tr class="separator:a8f8dd9f8f21a021f543461435076de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb9bc65a402435a12278a48289e52e" id="r_a64bb9bc65a402435a12278a48289e52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64bb9bc65a402435a12278a48289e52e">update</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>)</td></tr>
<tr class="separator:a64bb9bc65a402435a12278a48289e52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3e732370b0e478b213a6aa87998daf" id="r_a6e3e732370b0e478b213a6aa87998daf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3e732370b0e478b213a6aa87998daf">print</a> ()</td></tr>
<tr class="separator:a6e3e732370b0e478b213a6aa87998daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d4a0ac48dc1ede5ea6f47548e9d9c1" id="r_af9d4a0ac48dc1ede5ea6f47548e9d9c1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9d4a0ac48dc1ede5ea6f47548e9d9c1">print</a> (std::ostream &amp;out, const std::string &amp;AName, const std::string &amp;bName, const bool &amp;addRangeLimits)</td></tr>
<tr class="separator:af9d4a0ac48dc1ede5ea6f47548e9d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451792f99512d897d58df2ce24a0ae38" id="r_a451792f99512d897d58df2ce24a0ae38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451792f99512d897d58df2ce24a0ae38">removeRepeatedConstraints</a> ()</td></tr>
<tr class="separator:a451792f99512d897d58df2ce24a0ae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2858c3ced2705c3dcd0d450c56802a9e" id="r_a2858c3ced2705c3dcd0d450c56802a9e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2858c3ced2705c3dcd0d450c56802a9e">closestPoint</a> (const Eigen::VectorXd &amp;p_in, Eigen::VectorXd &amp;p_out)</td></tr>
<tr class="separator:a2858c3ced2705c3dcd0d450c56802a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a810c4d83d8edadc9db7d51f6b35d7" id="r_a30a810c4d83d8edadc9db7d51f6b35d7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30a810c4d83d8edadc9db7d51f6b35d7">closestPoint</a> (const Eigen::VectorXd &amp;p_in)</td></tr>
<tr class="separator:a30a810c4d83d8edadc9db7d51f6b35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e2241b8647902a67cc28b31fd0d7a7" id="r_a93e2241b8647902a67cc28b31fd0d7a7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e2241b8647902a67cc28b31fd0d7a7">closestPointExpandingEllipsoid</a> (<a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;ellipsoid, Eigen::VectorXd &amp;p_out)</td></tr>
<tr class="separator:a93e2241b8647902a67cc28b31fd0d7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6838ac72e7cd0c43b37677a98d360d94" id="r_a6838ac72e7cd0c43b37677a98d360d94"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6838ac72e7cd0c43b37677a98d360d94">isInside</a> (const Eigen::VectorXd &amp;p, const double &amp;tol=1.e-4)</td></tr>
<tr class="separator:a6838ac72e7cd0c43b37677a98d360d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2721b0339d20c310a7fabc02ebd02b7" id="r_aa2721b0339d20c310a7fabc02ebd02b7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2721b0339d20c310a7fabc02ebd02b7">isInsideSeparatingHyperplane</a> (const Eigen::VectorXd &amp;ai, const double &amp;bi, const double &amp;tol=1.e-4)</td></tr>
<tr class="separator:aa2721b0339d20c310a7fabc02ebd02b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b119d29d1c4e947e4a093f2620391d" id="r_ae1b119d29d1c4e947e4a093f2620391d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b119d29d1c4e947e4a093f2620391d">isInsideSeparatingHyperplanes</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>, const double &amp;tol=1.e-4)</td></tr>
<tr class="separator:ae1b119d29d1c4e947e4a093f2620391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abe1049107e6d77b9010b1111fe5e9f" id="r_a2abe1049107e6d77b9010b1111fe5e9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ellipsoid.html">Ellipsoid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2abe1049107e6d77b9010b1111fe5e9f">inscribedEllipsoid</a> ()</td></tr>
<tr class="separator:a2abe1049107e6d77b9010b1111fe5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa31dd50d92533a4549d65ab6f849e" id="r_a38fa31dd50d92533a4549d65ab6f849e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sphere.html">Sphere</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38fa31dd50d92533a4549d65ab6f849e">inscribedSphere</a> ()</td></tr>
<tr class="separator:a38fa31dd50d92533a4549d65ab6f849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f95b937e548b16fc52a157a757c4ef" id="r_af6f95b937e548b16fc52a157a757c4ef"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f95b937e548b16fc52a157a757c4ef">getCentroid</a> ()</td></tr>
<tr class="separator:af6f95b937e548b16fc52a157a757c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc766e1bd5c5991b4476a0045b2e253" id="r_a7cc766e1bd5c5991b4476a0045b2e253"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc766e1bd5c5991b4476a0045b2e253">intersect</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>)</td></tr>
<tr class="separator:a7cc766e1bd5c5991b4476a0045b2e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7a7e2a110fb15235b3635d58c5a950" id="r_a6a7a7e2a110fb15235b3635d58c5a950"><td class="memItemLeft" align="right" valign="top">virtual Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7a7e2a110fb15235b3635d58c5a950">getBoundingBox</a> ()</td></tr>
<tr class="separator:a6a7a7e2a110fb15235b3635d58c5a950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1a4b52a55777b6bb793b103c62b7a" id="r_a75b1a4b52a55777b6bb793b103c62b7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b1a4b52a55777b6bb793b103c62b7a">closestConstraint</a> (const Eigen::VectorXd &amp;p, Eigen::VectorXd &amp;ai, double &amp;bi)</td></tr>
<tr class="separator:a75b1a4b52a55777b6bb793b103c62b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b811d32e0e2a7ab95a73612f69d301" id="r_a20b811d32e0e2a7ab95a73612f69d301"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b811d32e0e2a7ab95a73612f69d301">eqConstraints</a> (const Eigen::VectorXd &amp;p, const double &amp;tol=1.e-4)</td></tr>
<tr class="separator:a20b811d32e0e2a7ab95a73612f69d301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_conic_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_conic_set')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_conic_set.html">ConicSet</a></td></tr>
<tr class="memitem:a42043705efd350d5972e290b1723a733 inherit pub_methods_class_conic_set" id="r_a42043705efd350d5972e290b1723a733"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ConicSet</b> (const int &amp;n)</td></tr>
<tr class="separator:a42043705efd350d5972e290b1723a733 inherit pub_methods_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3444d9afa77bc581aeb042b82ec04f inherit pub_methods_class_conic_set" id="r_a0a3444d9afa77bc581aeb042b82ec04f"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ConicSet</b> (const <a class="el" href="class_conic_set.html">ConicSet</a> &amp;conicSet)</td></tr>
<tr class="separator:a0a3444d9afa77bc581aeb042b82ec04f inherit pub_methods_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3ffda8db043fb84e82e7655d90844c17" id="r_a3ffda8db043fb84e82e7655d90844c17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ffda8db043fb84e82e7655d90844c17">vert2con</a> (const Eigen::MatrixXd &amp;v, Eigen::MatrixXd &amp;A_out, Eigen::VectorXd &amp;b_out)</td></tr>
<tr class="separator:a3ffda8db043fb84e82e7655d90844c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e19926e45e0ec3de10eabbefa33a74" id="r_af2e19926e45e0ec3de10eabbefa33a74"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e19926e45e0ec3de10eabbefa33a74">removeRepeatedConstraints</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>, Eigen::MatrixXd &amp;Aout, Eigen::VectorXd &amp;bout)</td></tr>
<tr class="separator:af2e19926e45e0ec3de10eabbefa33a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ae75f29018e30b0de0ad103d3b471" id="r_a193ae75f29018e30b0de0ad103d3b471"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193ae75f29018e30b0de0ad103d3b471">con2vert</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>, Eigen::MatrixXd &amp;v)</td></tr>
<tr class="separator:a193ae75f29018e30b0de0ad103d3b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1250defbdacc5ac8936f01203ecd8" id="r_a3fa1250defbdacc5ac8936f01203ecd8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa1250defbdacc5ac8936f01203ecd8">inscribedEllipsoidVolume</a> (const Eigen::MatrixXd &amp;<a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a>, const Eigen::VectorXd &amp;<a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a>)</td></tr>
<tr class="separator:a3fa1250defbdacc5ac8936f01203ecd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6802059ac81a600aef3194dd2137ae50" id="r_a6802059ac81a600aef3194dd2137ae50"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6802059ac81a600aef3194dd2137ae50">intersect</a> (const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;polyhedron1, const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;polyhedron2)</td></tr>
<tr class="separator:a6802059ac81a600aef3194dd2137ae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8a53df2a45de769e3ee35998689d719f" id="r_a8a53df2a45de769e3ee35998689d719f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a53df2a45de769e3ee35998689d719f">A</a></td></tr>
<tr class="separator:a8a53df2a45de769e3ee35998689d719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42daf765d70025964a665139b19f5a2b" id="r_a42daf765d70025964a665139b19f5a2b"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42daf765d70025964a665139b19f5a2b">b</a></td></tr>
<tr class="separator:a42daf765d70025964a665139b19f5a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_conic_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_class_conic_set')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_conic_set.html">ConicSet</a></td></tr>
<tr class="memitem:a6106df3463e06e75c83f821de6aff7a4 inherit pub_attribs_class_conic_set" id="r_a6106df3463e06e75c83f821de6aff7a4"><td class="memItemLeft" align="right" valign="top">
const int&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a6106df3463e06e75c83f821de6aff7a4 inherit pub_attribs_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a387209adcfb759384dcce05b6051f367" id="r_a387209adcfb759384dcce05b6051f367"><td class="memItemLeft" align="right" valign="top"><a id="a387209adcfb759384dcce05b6051f367" name="a387209adcfb759384dcce05b6051f367"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateClosestPointEllipsoidQPSolver</b> ()</td></tr>
<tr class="separator:a387209adcfb759384dcce05b6051f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5139ef084701cebc01283d6c508a13bb" id="r_a5139ef084701cebc01283d6c508a13bb"><td class="memItemLeft" align="right" valign="top"><a id="a5139ef084701cebc01283d6c508a13bb" name="a5139ef084701cebc01283d6c508a13bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeInscribedEllipsoid</b> ()</td></tr>
<tr class="separator:a5139ef084701cebc01283d6c508a13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca574cb34a0d424a967e1707a3c92f4" id="r_a6ca574cb34a0d424a967e1707a3c92f4"><td class="memItemLeft" align="right" valign="top"><a id="a6ca574cb34a0d424a967e1707a3c92f4" name="a6ca574cb34a0d424a967e1707a3c92f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeInscribedSphere</b> ()</td></tr>
<tr class="separator:a6ca574cb34a0d424a967e1707a3c92f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d355adf31cd034cf82ace2cc40287" id="r_a4b8d355adf31cd034cf82ace2cc40287"><td class="memItemLeft" align="right" valign="top"><a id="a4b8d355adf31cd034cf82ace2cc40287" name="a4b8d355adf31cd034cf82ace2cc40287"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateClosestPointSolver</b> ()</td></tr>
<tr class="separator:a4b8d355adf31cd034cf82ace2cc40287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3704463a3c54bd2006d35d23ec87f932" id="r_a3704463a3c54bd2006d35d23ec87f932"><td class="memItemLeft" align="right" valign="top"><a id="a3704463a3c54bd2006d35d23ec87f932" name="a3704463a3c54bd2006d35d23ec87f932"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateClosestPointEllipsoidSolver</b> ()</td></tr>
<tr class="separator:a3704463a3c54bd2006d35d23ec87f932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd82dc33f1481c651161cc64f9714c5f" id="r_abd82dc33f1481c651161cc64f9714c5f"><td class="memItemLeft" align="right" valign="top"><a id="abd82dc33f1481c651161cc64f9714c5f" name="abd82dc33f1481c651161cc64f9714c5f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateIsInsideSeparatingHyperplaneSolver</b> ()</td></tr>
<tr class="separator:abd82dc33f1481c651161cc64f9714c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b8cac332bb17a1b7ed99a3ebc8cadb" id="r_a36b8cac332bb17a1b7ed99a3ebc8cadb"><td class="memItemLeft" align="right" valign="top"><a id="a36b8cac332bb17a1b7ed99a3ebc8cadb" name="a36b8cac332bb17a1b7ed99a3ebc8cadb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateInscribedEllipsoidSolver</b> ()</td></tr>
<tr class="separator:a36b8cac332bb17a1b7ed99a3ebc8cadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a10706bbc21b16c51f12498b7b71a4e1f" id="r_a10706bbc21b16c51f12498b7b71a4e1f"><td class="memItemLeft" align="right" valign="top"><a id="a10706bbc21b16c51f12498b7b71a4e1f" name="a10706bbc21b16c51f12498b7b71a4e1f"></a>
std::shared_ptr&lt; ndarray&lt; double, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>A_ptr</b></td></tr>
<tr class="separator:a10706bbc21b16c51f12498b7b71a4e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca78dfdd16075787f6920109b00c971" id="r_abca78dfdd16075787f6920109b00c971"><td class="memItemLeft" align="right" valign="top"><a id="abca78dfdd16075787f6920109b00c971" name="abca78dfdd16075787f6920109b00c971"></a>
std::shared_ptr&lt; ndarray&lt; double, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>b_ptr</b></td></tr>
<tr class="separator:abca78dfdd16075787f6920109b00c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b89e4c39408dcdd8eeac0c792a0fec3" id="r_a2b89e4c39408dcdd8eeac0c792a0fec3"><td class="memItemLeft" align="right" valign="top"><a id="a2b89e4c39408dcdd8eeac0c792a0fec3" name="a2b89e4c39408dcdd8eeac0c792a0fec3"></a>
Model::t&#160;</td><td class="memItemRight" valign="bottom"><b>MClosestPoint</b></td></tr>
<tr class="separator:a2b89e4c39408dcdd8eeac0c792a0fec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466554ffc1b6db099facddafe0318ff5" id="r_a466554ffc1b6db099facddafe0318ff5"><td class="memItemLeft" align="right" valign="top"><a id="a466554ffc1b6db099facddafe0318ff5" name="a466554ffc1b6db099facddafe0318ff5"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>xClosestPoint</b></td></tr>
<tr class="separator:a466554ffc1b6db099facddafe0318ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f80ebcb166b43c313739771ad4e0a7" id="r_a92f80ebcb166b43c313739771ad4e0a7"><td class="memItemLeft" align="right" valign="top"><a id="a92f80ebcb166b43c313739771ad4e0a7" name="a92f80ebcb166b43c313739771ad4e0a7"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>l</b></td></tr>
<tr class="separator:a92f80ebcb166b43c313739771ad4e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6d12ba60b9f15621518a1571abd7cd" id="r_a4b6d12ba60b9f15621518a1571abd7cd"><td class="memItemLeft" align="right" valign="top"><a id="a4b6d12ba60b9f15621518a1571abd7cd" name="a4b6d12ba60b9f15621518a1571abd7cd"></a>
<a class="el" href="class_ellipsoid.html">Ellipsoid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ellipsoid</b></td></tr>
<tr class="separator:a4b6d12ba60b9f15621518a1571abd7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a36c5b8d221619bc2ba23da050e72f" id="r_a43a36c5b8d221619bc2ba23da050e72f"><td class="memItemLeft" align="right" valign="top"><a id="a43a36c5b8d221619bc2ba23da050e72f" name="a43a36c5b8d221619bc2ba23da050e72f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>computedInscribedEllipsoid</b> =false</td></tr>
<tr class="separator:a43a36c5b8d221619bc2ba23da050e72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d17660334af42771ed4f8c1e1b707e" id="r_ad8d17660334af42771ed4f8c1e1b707e"><td class="memItemLeft" align="right" valign="top"><a id="ad8d17660334af42771ed4f8c1e1b707e" name="ad8d17660334af42771ed4f8c1e1b707e"></a>
<a class="el" href="class_sphere.html">Sphere</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sphere</b></td></tr>
<tr class="separator:ad8d17660334af42771ed4f8c1e1b707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f7b3690c70ce413bb0aa55f99aa1d6" id="r_a35f7b3690c70ce413bb0aa55f99aa1d6"><td class="memItemLeft" align="right" valign="top"><a id="a35f7b3690c70ce413bb0aa55f99aa1d6" name="a35f7b3690c70ce413bb0aa55f99aa1d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>computedInscribedSphere</b> =false</td></tr>
<tr class="separator:a35f7b3690c70ce413bb0aa55f99aa1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427581ecc960d98a6b0facd6c006456c" id="r_a427581ecc960d98a6b0facd6c006456c"><td class="memItemLeft" align="right" valign="top"><a id="a427581ecc960d98a6b0facd6c006456c" name="a427581ecc960d98a6b0facd6c006456c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>solverClosestPointAllocated</b> =false</td></tr>
<tr class="separator:a427581ecc960d98a6b0facd6c006456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82460007fd2d055becabd52bd3caae21" id="r_a82460007fd2d055becabd52bd3caae21"><td class="memItemLeft" align="right" valign="top"><a id="a82460007fd2d055becabd52bd3caae21" name="a82460007fd2d055becabd52bd3caae21"></a>
Model::t&#160;</td><td class="memItemRight" valign="bottom"><b>MClosestPointEllipsoid</b></td></tr>
<tr class="separator:a82460007fd2d055becabd52bd3caae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada581b8ca9a72f1cf9c7c8a1d2cf0228" id="r_ada581b8ca9a72f1cf9c7c8a1d2cf0228"><td class="memItemLeft" align="right" valign="top"><a id="ada581b8ca9a72f1cf9c7c8a1d2cf0228" name="ada581b8ca9a72f1cf9c7c8a1d2cf0228"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>xClosestPointEllipsoid</b></td></tr>
<tr class="separator:ada581b8ca9a72f1cf9c7c8a1d2cf0228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59f0f256590ad8aa2ab4fe9b253c671" id="r_ae59f0f256590ad8aa2ab4fe9b253c671"><td class="memItemLeft" align="right" valign="top"><a id="ae59f0f256590ad8aa2ab4fe9b253c671" name="ae59f0f256590ad8aa2ab4fe9b253c671"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>wClosestPointEllipsoid</b></td></tr>
<tr class="separator:ae59f0f256590ad8aa2ab4fe9b253c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3b6540cb0367abb91ceff7f781ca79" id="r_a8c3b6540cb0367abb91ceff7f781ca79"><td class="memItemLeft" align="right" valign="top"><a id="a8c3b6540cb0367abb91ceff7f781ca79" name="a8c3b6540cb0367abb91ceff7f781ca79"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>alphaClosestPointEllipsoid</b></td></tr>
<tr class="separator:a8c3b6540cb0367abb91ceff7f781ca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7847d71f6d423d518ee765141d51c2bf" id="r_a7847d71f6d423d518ee765141d51c2bf"><td class="memItemLeft" align="right" valign="top"><a id="a7847d71f6d423d518ee765141d51c2bf" name="a7847d71f6d423d518ee765141d51c2bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>solverClosestPointEllipsoidAllocated</b> = false</td></tr>
<tr class="separator:a7847d71f6d423d518ee765141d51c2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88bcf13e89c7440c2cb8b10c2bb99f5" id="r_af88bcf13e89c7440c2cb8b10c2bb99f5"><td class="memItemLeft" align="right" valign="top"><a id="af88bcf13e89c7440c2cb8b10c2bb99f5" name="af88bcf13e89c7440c2cb8b10c2bb99f5"></a>
Model::t&#160;</td><td class="memItemRight" valign="bottom"><b>MIsInsideSeparatingHyperplane</b></td></tr>
<tr class="separator:af88bcf13e89c7440c2cb8b10c2bb99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad605fe5951c698d798fac9da4c590d25" id="r_ad605fe5951c698d798fac9da4c590d25"><td class="memItemLeft" align="right" valign="top"><a id="ad605fe5951c698d798fac9da4c590d25" name="ad605fe5951c698d798fac9da4c590d25"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>xIsInsideSeparatingHyperplane</b></td></tr>
<tr class="separator:ad605fe5951c698d798fac9da4c590d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809a2c89dd504dcee28042f6206c7987" id="r_a809a2c89dd504dcee28042f6206c7987"><td class="memItemLeft" align="right" valign="top"><a id="a809a2c89dd504dcee28042f6206c7987" name="a809a2c89dd504dcee28042f6206c7987"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>solverIsInsideSeparatingHyperplaneAllocated</b> = false</td></tr>
<tr class="separator:a809a2c89dd504dcee28042f6206c7987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ad51c03cd102dc2c037cfbc2a2c0ee" id="r_ae5ad51c03cd102dc2c037cfbc2a2c0ee"><td class="memItemLeft" align="right" valign="top"><a id="ae5ad51c03cd102dc2c037cfbc2a2c0ee" name="ae5ad51c03cd102dc2c037cfbc2a2c0ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numIsInsideSeparatingHyperplanes</b> = 0</td></tr>
<tr class="separator:ae5ad51c03cd102dc2c037cfbc2a2c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf0e0d4291a71f33df8d34fe7e17105" id="r_afbf0e0d4291a71f33df8d34fe7e17105"><td class="memItemLeft" align="right" valign="top"><a id="afbf0e0d4291a71f33df8d34fe7e17105" name="afbf0e0d4291a71f33df8d34fe7e17105"></a>
Model::t&#160;</td><td class="memItemRight" valign="bottom"><b>MInscribedEllipsoid</b></td></tr>
<tr class="separator:afbf0e0d4291a71f33df8d34fe7e17105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43282acd0a75e8dddc0d47d9fda3d36b" id="r_a43282acd0a75e8dddc0d47d9fda3d36b"><td class="memItemLeft" align="right" valign="top"><a id="a43282acd0a75e8dddc0d47d9fda3d36b" name="a43282acd0a75e8dddc0d47d9fda3d36b"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>xInscribedEllipsoid</b></td></tr>
<tr class="separator:a43282acd0a75e8dddc0d47d9fda3d36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90d599e42b01b5d6876f7bccd3578df" id="r_ad90d599e42b01b5d6876f7bccd3578df"><td class="memItemLeft" align="right" valign="top"><a id="ad90d599e42b01b5d6876f7bccd3578df" name="ad90d599e42b01b5d6876f7bccd3578df"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>CInscribedEllipsoid</b></td></tr>
<tr class="separator:ad90d599e42b01b5d6876f7bccd3578df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb3717235f2340c5b336113c51f1ba" id="r_aebcb3717235f2340c5b336113c51f1ba"><td class="memItemLeft" align="right" valign="top"><a id="aebcb3717235f2340c5b336113c51f1ba" name="aebcb3717235f2340c5b336113c51f1ba"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>tInscribedEllipsoid</b></td></tr>
<tr class="separator:aebcb3717235f2340c5b336113c51f1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4469aefbbaa2a059f8aeb4de1600b6b" id="r_af4469aefbbaa2a059f8aeb4de1600b6b"><td class="memItemLeft" align="right" valign="top"><a id="af4469aefbbaa2a059f8aeb4de1600b6b" name="af4469aefbbaa2a059f8aeb4de1600b6b"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>YInscribedEllipsoid</b></td></tr>
<tr class="separator:af4469aefbbaa2a059f8aeb4de1600b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb3ca1525550d9991f53e38157bb5e" id="r_adecb3ca1525550d9991f53e38157bb5e"><td class="memItemLeft" align="right" valign="top"><a id="adecb3ca1525550d9991f53e38157bb5e" name="adecb3ca1525550d9991f53e38157bb5e"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>ZInscribedEllipsoid</b></td></tr>
<tr class="separator:adecb3ca1525550d9991f53e38157bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad51baedaa686c2d18608fb1ffeb6a8" id="r_a2ad51baedaa686c2d18608fb1ffeb6a8"><td class="memItemLeft" align="right" valign="top"><a id="a2ad51baedaa686c2d18608fb1ffeb6a8" name="a2ad51baedaa686c2d18608fb1ffeb6a8"></a>
Variable::t&#160;</td><td class="memItemRight" valign="bottom"><b>DZInscribedEllipsoid</b></td></tr>
<tr class="separator:a2ad51baedaa686c2d18608fb1ffeb6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06c73c50c11f81e5b70d004e605eb8c" id="r_af06c73c50c11f81e5b70d004e605eb8c"><td class="memItemLeft" align="right" valign="top"><a id="af06c73c50c11f81e5b70d004e605eb8c" name="af06c73c50c11f81e5b70d004e605eb8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>solverInscribedEllipsoidAllocated</b> = false</td></tr>
<tr class="separator:af06c73c50c11f81e5b70d004e605eb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_conic_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_conic_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_conic_set.html">ConicSet</a></td></tr>
<tr class="memitem:a5d5a983b6f68e7dfe3097dea39a990f4 inherit pro_attribs_class_conic_set" id="r_a5d5a983b6f68e7dfe3097dea39a990f4"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>centroidComputed</b> =false</td></tr>
<tr class="separator:a5d5a983b6f68e7dfe3097dea39a990f4 inherit pro_attribs_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d90827e38a8f0f68a6a676e41b205a inherit pro_attribs_class_conic_set" id="r_ad4d90827e38a8f0f68a6a676e41b205a"><td class="memItemLeft" align="right" valign="top">
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>centroid</b></td></tr>
<tr class="separator:ad4d90827e38a8f0f68a6a676e41b205a inherit pro_attribs_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bb285a47adb51856a5c812c875b518 inherit pro_attribs_class_conic_set" id="r_a84bb285a47adb51856a5c812c875b518"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bbComputed</b> = false</td></tr>
<tr class="separator:a84bb285a47adb51856a5c812c875b518 inherit pro_attribs_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011fe3d9a42874d408e3a32c06da5e03 inherit pro_attribs_class_conic_set" id="r_a011fe3d9a42874d408e3a32c06da5e03"><td class="memItemLeft" align="right" valign="top">
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>bb</b></td></tr>
<tr class="separator:a011fe3d9a42874d408e3a32c06da5e03 inherit pro_attribs_class_conic_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_polyhedron.html">Polyhedron</a> class is used to define a polyhedron \(\mathcal{P}(A,b)=\{Ax\leq b \forall x\in\mathcal{C}\}\), being \(Ax\leq b\) its hyperplanes (the class does not explicitly compute polyhedron vertices) and \(\mathcal{C}\) the configuration space. This class uses Mosek to allocate some solvers for cached performance, i.e.: computing the distance of a point to the polyhedron. As long as the polyhedron doesn't change the number of constraints the cached computation will be kepts in memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a37e84952f6ff4d4190076ce2fe269ee8" name="a37e84952f6ff4d4190076ce2fe269ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e84952f6ff4d4190076ce2fe269ee8">&#9670;&#160;</a></span>Polyhedron() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">const int &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an empty polyhedron with the specified dimension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="class_polyhedron.html">Polyhedron</a> dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac620c35abc2f14019b2bfc86aa839d8b" name="ac620c35abc2f14019b2bfc86aa839d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac620c35abc2f14019b2bfc86aa839d8b">&#9670;&#160;</a></span>Polyhedron() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a polyhedron \(\mathcal{P}(A,b)=\{Ax\leq b \forall x\in\mathcal{C}\}\) with the specified constraints, being \(\mathcal{C}\) the configuration space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Contraints matrix \(A\in\mathbb{R}^{m\times n}\), being \(m\) the number of constraints and \(n\) the polyhedron dimension. Rows of \(A\) are normalized </td></tr>
    <tr><td class="paramname">b</td><td>Contraints intercepts \(b\in\mathbb{R}^{m}\), being \(m\) the number of constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a75082a4ec97a9190e7a6b74a6a0abb" name="a6a75082a4ec97a9190e7a6b74a6a0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a75082a4ec97a9190e7a6b74a6a0abb">&#9670;&#160;</a></span>Polyhedron() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polyhedron::Polyhedron </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyhedron</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyhedron</td><td>Another polyhedron </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f8dd9f8f21a021f543461435076de8a" name="a8f8dd9f8f21a021f543461435076de8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8dd9f8f21a021f543461435076de8a">&#9670;&#160;</a></span>~Polyhedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Polyhedron::~Polyhedron </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_polyhedron.html">Polyhedron</a> destructor (deallocates memory of solvers). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a75b1a4b52a55777b6bb793b103c62b7a" name="a75b1a4b52a55777b6bb793b103c62b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1a4b52a55777b6bb793b103c62b7a">&#9670;&#160;</a></span>closestConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Polyhedron::closestConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ai</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>bi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constraint that is closest to the point \(p\in\mathcal{P}(A,b)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td><a class="el" href="class_point.html">Point</a> belonging to the polyhedron </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ai</td><td>Constraint normal vector of the constraint closest to the point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bi</td><td>Constraint intercept of the constraint closest to the point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30a810c4d83d8edadc9db7d51f6b35d7" name="a30a810c4d83d8edadc9db7d51f6b35d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a810c4d83d8edadc9db7d51f6b35d7">&#9670;&#160;</a></span>closestPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Polyhedron::closestPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p_in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the distance between \(x_{in}\) and the closest point \(x^{*}\) of the polyhedron to the given input point. The first time this function is called, the solver is allocated and can be used for cached computations for further queries. </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\min_{x} &amp;\|x_{in}-x\|\\ Ax&amp;\leq b\end{eqnarray*}
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_in</td><td>Input point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance of the closest point </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#ac4bc2585573244db939847799f5769c0">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="a2858c3ced2705c3dcd0d450c56802a9e" name="a2858c3ced2705c3dcd0d450c56802a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2858c3ced2705c3dcd0d450c56802a9e">&#9670;&#160;</a></span>closestPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Polyhedron::closestPoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p_out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the closest point \(x^{*}\) of the polyhedron to a given input point \(x_{in}\). The first time this function is called, the solver is allocated and can be used for cached computations for further queries. </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\min_{x} &amp;\|x_{in}-x\|\\ Ax&amp;\leq b\end{eqnarray*}
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_in</td><td>Input point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_out</td><td>Computed closest point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance of the closest point </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a4aece36c385229a541b7aba0eea55d76">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="a93e2241b8647902a67cc28b31fd0d7a7" name="a93e2241b8647902a67cc28b31fd0d7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e2241b8647902a67cc28b31fd0d7a7">&#9670;&#160;</a></span>closestPointExpandingEllipsoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Polyhedron::closestPointExpandingEllipsoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ellipsoid.html">Ellipsoid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ellipsoid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p_out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the closest point \(x^{*}\) of the polyhedron to a given ellipsoid \(\mathcal{E}(C,d)=\{x=C\tilde{x}+d\ |\ \|\tilde{x}\|\leq 1\}\). The first time this function is called, the solver is allocated and can be used for cached computations for further queries. </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\min_{x,\alpha} &amp;\alpha\\ Ax&amp;\leq b\\ \left[\begin{array}{c}\alpha\\ C^{-1}(x-d)\end{array}\right]\in&amp;\mathcal{Q}^{n+1}\end{eqnarray*}
</p>
<p> being \(\mathcal{Q}^{n}\) the domain of quadratic cones \(\mathcal{Q}^{n}=\{x_1\geq\sqrt{x_2^2+\ldots+x_n^2}\}\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ellipsoid</td><td>Input ellipsoid \(\mathcal{E}(C,d)\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_out</td><td>Computed closest point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance of the closest point </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a078251158067bd04e65d646e90ee2bbd">PolyhedronObstacleCircularRobot</a>, and <a class="el" href="class_polyhedron_v.html#aaaece58b692401a3c93106cfe3e71c21">PolyhedronV</a>.</p>

</div>
</div>
<a id="a193ae75f29018e30b0de0ad103d3b471" name="a193ae75f29018e30b0de0ad103d3b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ae75f29018e30b0de0ad103d3b471">&#9670;&#160;</a></span>con2vert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Polyhedron::con2vert </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute vertices of a polyhedron from its hyperplane constraints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Matrix with \(v\in\mathbb{R}^{n\times p}\), being \(n\) the polyhedron dimension and \(p\) the number of vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Computed contraints matrix \(A\in\mathbb{R}^{m\times n}\), being \(m\) the number of constraints and \(n\) the polyhedron dimension </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Computed contraints intercepts \(b\in\mathbb{R}^{m}\), being \(m\) the number of constraints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b811d32e0e2a7ab95a73612f69d301" name="a20b811d32e0e2a7ab95a73612f69d301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b811d32e0e2a7ab95a73612f69d301">&#9670;&#160;</a></span>eqConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Polyhedron::eqConstraints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.e-4</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the indexes of constraints \(\{a_{i},b_{i}\}\) that satisfy \(|a_{i}p-b_{i}|\delta\) for a given point belongin to the polyhedron boundary with tolerance \(\delta\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="class_point.html">Point</a> \(p\) belonging to the polyhedron boundary </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance \(\delta\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the indexes of the contraints satisfying the condition </dd></dl>

</div>
</div>
<a id="a6a7a7e2a110fb15235b3635d58c5a950" name="a6a7a7e2a110fb15235b3635d58c5a950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7a7e2a110fb15235b3635d58c5a950">&#9670;&#160;</a></span>getBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Polyhedron::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounding box of the polyhedron. The function is cached, meaning that the first time is called computes the bounding box, while subsequent calls will return the computed bounding box if the polyhedron is not changed. The bounding box is defined as a set of vertices. </p><dl class="section return"><dt>Returns</dt><dd>Bounding box vertices with dimensions \(n\times 2n\), being \(n\) the dimension of the polyhedron </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#ab5056e188079342cc8d736cb427539aa">PolyhedronObstacleCircularRobot</a>, and <a class="el" href="class_polyhedron_v.html#ab9f4fbc1444caa48bfe1267f83038069">PolyhedronV</a>.</p>

</div>
</div>
<a id="af6f95b937e548b16fc52a157a757c4ef" name="af6f95b937e548b16fc52a157a757c4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f95b937e548b16fc52a157a757c4ef">&#9670;&#160;</a></span>getCentroid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd Polyhedron::getCentroid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the centroid of the inscribed <a class="el" href="class_sphere.html">Sphere</a> with the maximum volume in the polyhedron. The computations are cached, meaning that the first time, the function will allocate memory for a solver to compute the sphere, but on subsequent calls, the computed centroid will be returned. </p><dl class="section return"><dt>Returns</dt><dd>Vector \(c\in\mathbb{R}^{n}\) with the polyhedron centroid </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a2c4d5474b09d89923a3ca3758f0072e3">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="a2abe1049107e6d77b9010b1111fe5e9f" name="a2abe1049107e6d77b9010b1111fe5e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abe1049107e6d77b9010b1111fe5e9f">&#9670;&#160;</a></span>inscribedEllipsoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ellipsoid.html">Ellipsoid</a> Polyhedron::inscribedEllipsoid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="class_ellipsoid.html">Ellipsoid</a> \(\mathcal{E}(C,c)=\{x=C\tilde{x}+c\ |\ \|\tilde{x}\|\leq 1\}\) with the maximum volume inscribed in the polyhedron. The solver is cached and subsequent calls will return the computed ellipsoid if the polyhedron is not changed. This is equivalent to solve the following optimitization problem: </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\max_{C,c} &amp;\log|C|\\ \left[\begin{array}{c}b-A\cdot c\ A\cdot C\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\\ \left[\begin{array}{c}b_{\mathcal{C}}-A_{\mathcal{C}}\cdot c\ A_{\mathcal{C}}\cdot C\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\end{eqnarray*}
</p>
<p> being \(\mathcal{Q}^{n}\) the domain of quadratic cones \(\mathcal{Q}^{n}=\{x_1\geq\sqrt{x_2^2+\ldots+x_n^2}\}\), with \(C\succeq 0\) and \(A_{\mathcal{C}}\in\mathbb{R}^{2n\times n}\) and \(b_{\mathcal{C}}\in\mathbb{R}^{2n}\) the separating hyperplanes of the configuration space. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ellipsoid.html">Ellipsoid</a> \(\mathcal{E}(C,d)=\{x=C\tilde{x}+d\ |\ \|\tilde{x}\|\leq 1\}\) inscribed in the polyhedron </dd></dl>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#ae3cf356645de3cbe1b1620fdc06b312b">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="a3fa1250defbdacc5ac8936f01203ecd8" name="a3fa1250defbdacc5ac8936f01203ecd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa1250defbdacc5ac8936f01203ecd8">&#9670;&#160;</a></span>inscribedEllipsoidVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Polyhedron::inscribedEllipsoidVolume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the volume of the <a class="el" href="class_ellipsoid.html">Ellipsoid</a> \(\mathcal{E}(C,c)=\{x=C\tilde{x}+c\ |\ \|\tilde{x}\|\leq 1\}\) with the maximum volume inscribed in the polyhedron. The function is a static method, and thus the solver is NOT cached and subsequent calls will allocate and deallocate memory used by the solver. This is equivalent to solve the following optimitization problem: </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\max_{C,c} &amp;\log|C|\\ \left[\begin{array}{c}b-A\cdot c\ A\cdot C\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\\ \left[\begin{array}{c}b_{\mathcal{C}}-A_{\mathcal{C}}\cdot c\ A_{\mathcal{C}}\cdot C\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\end{eqnarray*}
</p>
<p> being \(\mathcal{Q}^{n}\) the domain of quadratic cones \(\mathcal{Q}^{n}=\{x_1\geq\sqrt{x_2^2+\ldots+x_n^2}\}\), with \(C\succeq 0\) and \(A_{\mathcal{C}}\in\mathbb{R}^{2n\times n}\) and \(b_{\mathcal{C}}\in\mathbb{R}^{2n}\) the separating hyperplanes of the configuration space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Constraints matrix of the polyhedron </td></tr>
    <tr><td class="paramname">b</td><td>Constraints intercepts of the polyhedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ellipsoid.html">Ellipsoid</a> \(\mathcal{E}(C,d)=\{x=C\tilde{x}+d\ |\ \|\tilde{x}\|\leq 1\}\) inscribed in the polyhedron </dd></dl>

</div>
</div>
<a id="a38fa31dd50d92533a4549d65ab6f849e" name="a38fa31dd50d92533a4549d65ab6f849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fa31dd50d92533a4549d65ab6f849e">&#9670;&#160;</a></span>inscribedSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sphere.html">Sphere</a> Polyhedron::inscribedSphere </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="class_sphere.html">Sphere</a> \(\mathcal{S}(r,c)=\{x=r\tilde{x}+c\ |\ \|\tilde{x}\|\leq 1\}\) with the maximum volume inscribed in the polyhedron. The solver is cached and subsequent calls will return the computed circle if the polyhedron is not changed. This is equivalent to solve the following optimitization problem: </p><p class="formulaDsp">
\begin{eqnarray*}x^{*}=\text{arg}\!\displaystyle\max_{r,c} &amp;r\\ \left[\begin{array}{c}b-A\cdot c\ r\cdot A\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\\ \left[\begin{array}{c}b_{\mathcal{C}}-A_{\mathcal{C}}\cdot c\ r\cdot A_{\mathcal{C}}\end{array}\right]^{T}\in&amp;\mathcal{Q}^{n+1}\times\mathcal{Q}^{n+1}\ldots\times \mathcal{Q}^{n+1}\end{eqnarray*}
</p>
<p> being \(\mathcal{Q}^{n}\) the domain of quadratic cones \(\mathcal{Q}^{n}=\{x_1\geq\sqrt{x_2^2+\ldots+x_n^2}\}\), with \(r\) being the sphere radius and \(A_{\mathcal{C}}\in\mathbb{R}^{2n\times n}\) and \(b_{\mathcal{C}}\in\mathbb{R}^{2n}\) the separating hyperplanes of the configuration space. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sphere.html">Sphere</a> \(\mathcal{S}(r,c)=\{x=r\tilde{x}+c\ |\ \|\tilde{x}\|\leq 1\}\) inscribed in the polyhedron </dd></dl>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a6a1a94619c81e55a3d219452023392f7">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="a7cc766e1bd5c5991b4476a0045b2e253" name="a7cc766e1bd5c5991b4476a0045b2e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc766e1bd5c5991b4476a0045b2e253">&#9670;&#160;</a></span>intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Polyhedron::intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the current polyhedron intersects with another polyhedron. Given another polyhedron \(\mathcal{P}&#39;(A&#39;,b&#39;)\), checks if \(\left[\begin{array}{c}A\\A&#39;\end{array}\right]\leq\left[\begin{array}{c}b\\b&#39;\end{array}\right]\) is valid for at least one point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Constraint matrix of the (another) polyhedron </td></tr>
    <tr><td class="paramname">b</td><td>Contraint intercept of the (another) polyhedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if polyhedron intersects with the current polyhedron </dd></dl>

</div>
</div>
<a id="a6802059ac81a600aef3194dd2137ae50" name="a6802059ac81a600aef3194dd2137ae50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6802059ac81a600aef3194dd2137ae50">&#9670;&#160;</a></span>intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Polyhedron::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyhedron1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_polyhedron.html">Polyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyhedron2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if two polyhedron intersect. Given \(\mathcal{P}_{1}(A_{1},b_{1})\) and \(\mathcal{P}_{2}(A_{2},b_{2})\) intersect, that is, checks if \(\left[\begin{array}{c}A_{1}\\A_{2}\end{array}\right]\leq\left[\begin{array}{c}b_{1}\\b_{2}\end{array}\right]\) is valid for at least one point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyhedron1</td><td><a class="el" href="class_polyhedron.html">Polyhedron</a> \(\mathcal{P}_{1}(A_{1},b_{1})\) </td></tr>
    <tr><td class="paramname">polyhedron2</td><td><a class="el" href="class_polyhedron.html">Polyhedron</a> \(\mathcal{P}_{2}(A_{2},b_{2})\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if polyhedra intersect </dd></dl>

</div>
</div>
<a id="a6838ac72e7cd0c43b37677a98d360d94" name="a6838ac72e7cd0c43b37677a98d360d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6838ac72e7cd0c43b37677a98d360d94">&#9670;&#160;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Polyhedron::isInside </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.e-4</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check is a point is inside the polyhedron by ensuring that all constraints are satisfied within a given tolerance \(\delta\). Rows of \(A\) are normalized. </p><p class="formulaDsp">
\[Ax-b\leq \delta \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="class_point.html">Point</a> to check if it is inside the polyhedron </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance \(\delta\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is inside the polyhedron, false otherwise. </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a608e2792d14e245f19d47c9239d3c389">PolyhedronObstacleCircularRobot</a>.</p>

</div>
</div>
<a id="aa2721b0339d20c310a7fabc02ebd02b7" name="aa2721b0339d20c310a7fabc02ebd02b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2721b0339d20c310a7fabc02ebd02b7">&#9670;&#160;</a></span>isInsideSeparatingHyperplane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Polyhedron::isInsideSeparatingHyperplane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>ai</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>bi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.e-4</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if part of the polyhedron is inside a given separating hyperplane (defined by the normal vector \(\tilde{a}_{i}\) and intercept \(\tilde{b}_{i}\) and considering a tolerance \(\delta\)). This is equivalent to check if the following problem is feasible: </p><p class="formulaDsp">
\begin{eqnarray*}\displaystyle\min &amp;\sum_{x} x\\ Ax-b&amp;\leq 0\\ \tilde{a}_{i}x-\tilde{b}_{i}&amp;\leq \delta\end{eqnarray*}
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ai</td><td>Normal vector of the separating hyperplane </td></tr>
    <tr><td class="paramname">bi</td><td>Intercept of the separating hyperplane </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance \(\delta\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if part of the polyhedron is inside the given separating hyperplane </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a115bce61a7b997a9c958d67cf0370d83">PolyhedronObstacleCircularRobot</a>, and <a class="el" href="class_polyhedron_v.html#a4883fb79af37200427dda08a04168cf4">PolyhedronV</a>.</p>

</div>
</div>
<a id="ae1b119d29d1c4e947e4a093f2620391d" name="ae1b119d29d1c4e947e4a093f2620391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b119d29d1c4e947e4a093f2620391d">&#9670;&#160;</a></span>isInsideSeparatingHyperplanes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Polyhedron::isInsideSeparatingHyperplanes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.e-4</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if part of the polyhedron is inside a given set of separating hyperplanes (considering a tolerance \(\delta\)). Only the last constraint (last row of \(A\) and \(b\)) is indeed considered. The function is cached so that it assumes that will be called every time a new separating hyperplane is added to the set. To reset the solver, you must call this function with an empty constraint set. This is equivalent to check if the following problem is feasible: </p><p class="formulaDsp">
\begin{eqnarray*}\displaystyle\min &amp;\sum_{x} x\\ Ax-b&amp;\leq 0\\ \tilde{A}x-\tilde{b}&amp;\leq I\cdot\delta\end{eqnarray*}
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Constraints matrix of the separating hyperplanes </td></tr>
    <tr><td class="paramname">b</td><td>Constraints intercepts of the separating hyperplanes </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance \(\delta\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if part of the polyhedron is inside the given separating hyperplane </dd></dl>

<p>Implements <a class="el" href="class_conic_set.html">ConicSet</a>.</p>

<p>Reimplemented in <a class="el" href="class_polyhedron_obstacle_circular_robot.html#a14e43cb17bf99b9c94e35862d22c74d0">PolyhedronObstacleCircularRobot</a>, and <a class="el" href="class_polyhedron_v.html#ac050799a7cac251508cf55ab404add5a">PolyhedronV</a>.</p>

</div>
</div>
<a id="a6e3e732370b0e478b213a6aa87998daf" name="a6e3e732370b0e478b213a6aa87998daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3e732370b0e478b213a6aa87998daf">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Polyhedron::print </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the polyhedron constraints on the console. </p>

<p>Reimplemented in <a class="el" href="class_polyhedron_v.html#a07a7ca7f181d8abbd693fac6b23df53d">PolyhedronV</a>.</p>

</div>
</div>
<a id="af9d4a0ac48dc1ede5ea6f47548e9d9c1" name="af9d4a0ac48dc1ede5ea6f47548e9d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d4a0ac48dc1ede5ea6f47548e9d9c1">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Polyhedron::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>AName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;</td>          <td class="paramname"><span class="paramname"><em>addRangeLimits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the polyhedron constraints on the specified output stream (using Matlab's syntax). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream to print the polyhedron </td></tr>
    <tr><td class="paramname">AName</td><td>Name of the variable to assign the constraints matrix \(A\) </td></tr>
    <tr><td class="paramname">bName</td><td>Name of the variable to assign the constraints intercepts \(b\) </td></tr>
    <tr><td class="paramname">addRangeLimits</td><td>If true, it adds to the printed polyhedron the range limits is is always a closed polyhedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output stream </dd></dl>

</div>
</div>
<a id="a451792f99512d897d58df2ce24a0ae38" name="a451792f99512d897d58df2ce24a0ae38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451792f99512d897d58df2ce24a0ae38">&#9670;&#160;</a></span>removeRepeatedConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Polyhedron::removeRepeatedConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove repeated constraints of this polyhedron. If any constraint is removed, the update method is internally executed so that allocated solvers do not fail on next calls. </p><dl class="section return"><dt>Returns</dt><dd>List with the indices of the removed constraints </dd></dl>

</div>
</div>
<a id="af2e19926e45e0ec3de10eabbefa33a74" name="af2e19926e45e0ec3de10eabbefa33a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e19926e45e0ec3de10eabbefa33a74">&#9670;&#160;</a></span>removeRepeatedConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Polyhedron::removeRepeatedConstraints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>Aout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>bout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a constraint matrix and intercepts \(A\in\mathbb{R}^{m\times n}\) and \(b\in\mathbb{R}^{m}\), constraint removal checks if the feasibility of the problem: </p><p class="formulaDsp">
\begin{eqnarray*}\displaystyle\min_{x} &amp;\sum x\\ A_{1,i-1}x&amp;\leq b_{1,i-1}\\ A_{i}x&amp;\geq b_{i} \\ A_{i+1,m}x&amp;\leq b_{i+1,m}\end{eqnarray*}
</p>
<p> If the problem is feasible then the constraint is redundant and can be removed. It returns the reduced constraint matrices and intercepts \(A\in\mathbb{R}^{l\times n}\) and \(b\in\mathbb{R}^{l}\), with \(l\leq m\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Constraints matrix \(A\in\mathbb{R}^{m\times n}\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Constraints intercepts \(b\in\mathbb{R}^{m}\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Aout</td><td>Reduced constraints matrix \(A\in\mathbb{R}^{l\times n}\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bout</td><td>Reduced constraints intercepts \(b\in\mathbb{R}^{l}\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List with the indices of the removed constraints </dd></dl>

</div>
</div>
<a id="a64bb9bc65a402435a12278a48289e52e" name="a64bb9bc65a402435a12278a48289e52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bb9bc65a402435a12278a48289e52e">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Polyhedron::update </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates hypeplanes \(A\in\mathbb{R}^{m\times n}\) and \(b\in\mathbb{R}^{m}\). If the number of constraints changes then it deallocates memory for allocated solvers. If the number of contraints are the same. It simply updates the internal variables A_ptr and b_ptr that solvers use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Contraints matrix \(A\in\mathbb{R}^{m\times n}\), being \(m\) the number of constraints and \(n\) the polyhedron dimension. Rows of \(A\) are normalized </td></tr>
    <tr><td class="paramname">b</td><td>Contraints intercepts \(b\in\mathbb{R}^{m}\), being \(m\) the number of constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ffda8db043fb84e82e7655d90844c17" name="a3ffda8db043fb84e82e7655d90844c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffda8db043fb84e82e7655d90844c17">&#9670;&#160;</a></span>vert2con()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Polyhedron::vert2con </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>A_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>b_out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes constraints from a set of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Matrix with \(v\in\mathbb{R}^{n\times p}\), being \(n\) the polyhedron dimension and \(p\) the number of vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_out</td><td>Computed contraints matrix \(A\in\mathbb{R}^{m\times n}\), being \(m\) the number of constraints and \(n\) the polyhedron dimension. Rows of \(A\) are normalized </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_out</td><td>Computed contraints intercepts \(b\in\mathbb{R}^{m}\), being \(m\) the number of constraints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8a53df2a45de769e3ee35998689d719f" name="a8a53df2a45de769e3ee35998689d719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a53df2a45de769e3ee35998689d719f">&#9670;&#160;</a></span>A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Polyhedron::A</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contraints matrix \(A\in\mathbb{R}^{m\times n}\), being \(m\) the number of constraints and \(n\) the polyhedron dimension. Rows of \(A\) must be normalized. </p>

</div>
</div>
<a id="a42daf765d70025964a665139b19f5a2b" name="a42daf765d70025964a665139b19f5a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42daf765d70025964a665139b19f5a2b">&#9670;&#160;</a></span>b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd Polyhedron::b</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contraints intercepts \(b\in\mathbb{R}^{m}\), being \(m\) the number of constraints. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/34696/source/repos/AStarIRIS/AStarIRIS/include/<a class="el" href="_polyhedron_8h_source.html">Polyhedron.h</a></li>
<li>C:/Users/34696/source/repos/AStarIRIS/AStarIRIS/src/<b>Polyhedron.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_polyhedron.html">Polyhedron</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
